# âš¡ ê¹€ì¹˜í”„ë¦¬ë¯¸ì—„ ì£¼ë¬¸ ì‹¤í–‰ ëª…ì„¸ (Ver 3.0)

## 1. ì‹¤í–‰ ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Order Execution System (Ver 3.0)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚   â”‚  Signal     â”‚ â†’   â”‚   Filter    â”‚ â†’   â”‚  Executor   â”‚           â”‚
â”‚   â”‚  Detector   â”‚     â”‚  (FX+Entry) â”‚     â”‚  (CCXT)     â”‚           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                    â”‚                    â”‚                  â”‚
â”‚         â”‚                    â”‚                    â–¼                  â”‚
â”‚         â”‚                    â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚         â”‚                    â”‚            â”‚   Upbit     â”‚           â”‚
â”‚         â”‚                    â”‚            â”‚ + Binance   â”‚           â”‚
â”‚         â”‚                    â”‚            â”‚  ë™ì‹œ ì‹¤í–‰   â”‚           â”‚
â”‚         â”‚                    â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                    â”‚                    â”‚                  â”‚
â”‚         â–¼                    â–¼                    â–¼                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚                   Exit Monitor                       â”‚          â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚          â”‚
â”‚   â”‚  â”‚  Track A    â”‚    OR    â”‚  Track B    â”‚          â”‚          â”‚
â”‚   â”‚  â”‚  (Target)   â”‚          â”‚ (Breakout)  â”‚          â”‚          â”‚
â”‚   â”‚  â”‚  0.7% ìµì ˆ  â”‚          â”‚ BBëŒíŒŒíƒˆì¶œ   â”‚          â”‚          â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Ver 3.0 ë³€ê²½ì‚¬í•­

| í•­ëª© | ê¸°ì¡´ | Ver 3.0 |
|:---|:---|:---|
| ì§„ì… í•„í„° | Z-Scoreë§Œ | **í™˜ìœ¨ í•„í„° + Z-Score** |
| ì²­ì‚° ë¡œì§ | ë‹¨ì¼ ëª©í‘œê°€ | **Dual Track (Target + Breakout)** |
| exit_reason | ì—†ìŒ | **'Target' / 'Breakout'** ê¸°ë¡ |

---

## 2. ì§„ì… ì‹¤í–‰ (Entry Execution)

### 2.1 ì§„ì… íë¦„ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Entry Flow (Ver 3.0)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚   [1] Z-Score íšŒê·€ ê°ì§€                                              â”‚
â”‚        â”‚                                                              â”‚
â”‚        â–¼                                                              â”‚
â”‚   [2] í™˜ìœ¨ í•„í„° ì²´í¬ (NEW)                                           â”‚
â”‚        â”œâ”€ í™˜ìœ¨ > MA_12h Ã— 1.001 â†’ â›” ì§„ì… ì°¨ë‹¨                       â”‚
â”‚        â””â”€ í™˜ìœ¨ â‰¤ MA_12h Ã— 1.001 â†’ âœ… ì§„ì… ì§„í–‰                       â”‚
â”‚                                     â”‚                                 â”‚
â”‚                                     â–¼                                 â”‚
â”‚   [3] ì§„ì… ë ˆë²¨ ê²°ì •                                                 â”‚
â”‚        â”œâ”€ Level 1: 40% (Z > -2.0 íšŒê·€)                               â”‚
â”‚        â”œâ”€ Level 2: 60% ì¶”ê°€ (Z > -2.5 íšŒê·€)                          â”‚
â”‚        â””â”€ Full: 100% (-2.5 ì§í–‰ í›„ íšŒê·€)                             â”‚
â”‚                     â”‚                                                 â”‚
â”‚                     â–¼                                                 â”‚
â”‚   [4] ë™ì‹œ ì£¼ë¬¸ ì‹¤í–‰                                                 â”‚
â”‚        â”œâ”€ Upbit: í˜„ë¬¼ BTC ë§¤ìˆ˜                                       â”‚
â”‚        â””â”€ Binance: BTCUSDT ì„ ë¬¼ SHORT                                â”‚
â”‚                                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ì§„ì… ì‹¤í–‰ ì½”ë“œ

```python
from dataclasses import dataclass
from enum import Enum
from typing import Optional
import asyncio

class EntryLevel(Enum):
    LEVEL1 = "level1"      # 40%
    LEVEL2 = "level2"      # 60% ì¶”ê°€
    FULL = "combined"      # 100%

@dataclass
class EntrySignal:
    level: EntryLevel
    zscore: float
    kimp: float
    fx_rate: float
    fx_ma_12h: float

@dataclass
class EntryResult:
    success: bool
    position_id: Optional[str]
    upbit_order_id: Optional[str]
    binance_order_id: Optional[str]
    error: Optional[str]

class EntryExecutor:
    """ì§„ì… ì‹¤í–‰ê¸° (Ver 3.0)"""
    
    def __init__(self, upbit_client, binance_client, config):
        self.upbit = upbit_client
        self.binance = binance_client
        self.config = config
        
        # í™˜ìœ¨ í•„í„° ì„¤ì •
        self.fx_surge_threshold = 1.001  # +0.1%
    
    async def execute_entry(self, signal: EntrySignal) -> EntryResult:
        """ì§„ì… ì‹¤í–‰"""
        
        # Step 1: í™˜ìœ¨ í•„í„° ì²´í¬ (Ver 3.0)
        if self._is_fx_blocked(signal.fx_rate, signal.fx_ma_12h):
            return EntryResult(
                success=False,
                position_id=None,
                upbit_order_id=None,
                binance_order_id=None,
                error=f"FX filter blocked: {signal.fx_rate:.2f} > {signal.fx_ma_12h * self.fx_surge_threshold:.2f}"
            )
        
        # Step 2: ì§„ì… ê¸ˆì•¡ ê³„ì‚°
        capital = self._calculate_entry_capital(signal.level)
        
        # Step 3: ë™ì‹œ ì£¼ë¬¸ ì‹¤í–‰
        try:
            upbit_order, binance_order = await asyncio.gather(
                self._execute_upbit_buy(capital['upbit']),
                self._execute_binance_short(capital['binance']),
                return_exceptions=True
            )
            
            # ë¡¤ë°± ì²´í¬
            if isinstance(upbit_order, Exception) or isinstance(binance_order, Exception):
                await self._rollback(upbit_order, binance_order)
                return EntryResult(
                    success=False,
                    position_id=None,
                    upbit_order_id=None,
                    binance_order_id=None,
                    error=f"Order failed: {upbit_order}, {binance_order}"
                )
            
            # í¬ì§€ì…˜ ìƒì„±
            position_id = await self._create_position(
                signal, upbit_order, binance_order
            )
            
            return EntryResult(
                success=True,
                position_id=position_id,
                upbit_order_id=upbit_order['id'],
                binance_order_id=binance_order['id'],
                error=None
            )
            
        except Exception as e:
            return EntryResult(
                success=False,
                position_id=None,
                upbit_order_id=None,
                binance_order_id=None,
                error=str(e)
            )
    
    def _is_fx_blocked(self, current_rate: float, ma_12h: float) -> bool:
        """í™˜ìœ¨ í•„í„° ì²´í¬"""
        threshold = ma_12h * self.fx_surge_threshold
        return current_rate > threshold
    
    def _calculate_entry_capital(self, level: EntryLevel) -> dict:
        """ì§„ì… ìë³¸ ê³„ì‚°"""
        trading_capital = self.config.trading_capital  # 38,000,000
        
        ratios = {
            EntryLevel.LEVEL1: 0.40,
            EntryLevel.LEVEL2: 0.60,
            EntryLevel.FULL: 1.00
        }
        
        total = trading_capital * ratios[level]
        
        return {
            'total': total,
            'upbit': total * 0.5,      # í˜„ë¬¼ 50%
            'binance': total * 0.5     # ì„ ë¬¼ 50%
        }
    
    async def _execute_upbit_buy(self, amount_krw: float):
        """ì—…ë¹„íŠ¸ í˜„ë¬¼ ë§¤ìˆ˜"""
        return await self.upbit.create_market_buy_order(
            symbol='BTC/KRW',
            amount=None,  # KRW ê¸ˆì•¡ ê¸°ì¤€
            params={'cost': amount_krw}
        )
    
    async def _execute_binance_short(self, amount_krw: float):
        """ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ìˆ"""
        # KRW â†’ USDT ë³€í™˜
        usdt_amount = amount_krw / self.config.current_fx_rate
        btc_amount = usdt_amount / self.config.current_btc_price
        
        return await self.binance.create_market_sell_order(
            symbol='BTC/USDT:USDT',
            amount=btc_amount
        )
    
    async def _rollback(self, upbit_order, binance_order):
        """ì‹¤íŒ¨ ì‹œ ë¡¤ë°±"""
        if not isinstance(upbit_order, Exception):
            await self.upbit.create_market_sell_order(
                symbol='BTC/KRW',
                amount=upbit_order['filled']
            )
        
        if not isinstance(binance_order, Exception):
            await self.binance.create_market_buy_order(
                symbol='BTC/USDT:USDT',
                amount=binance_order['filled']
            )
```

---

## 3. ì²­ì‚° ì‹¤í–‰ (Exit Execution) - Dual Track

### 3.1 Dual Track ì²­ì‚° íë¦„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Dual Track Exit System (Ver 3.0)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚   [ë§¤ 1ì´ˆ ì²´í¬]                                                      â”‚
â”‚        â”‚                                                              â”‚
â”‚        â”œâ”€â”€ Track A: ì •ìƒ ìµì ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚        â”‚    ì¡°ê±´: (í˜„ì¬ê¹€í”„ - ì§„ì…ê¹€í”„) â‰¥ 0.7%                       â”‚
â”‚        â”‚    í–‰ë™: ì „ëŸ‰ ì²­ì‚°                                          â”‚
â”‚        â”‚    ê¸°ë¡: exit_reason = 'Target'                            â”‚
â”‚        â”‚                                                              â”‚
â”‚        â””â”€â”€ Track B: Breakout íƒˆì¶œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚             ì¡°ê±´ 1: (í˜„ì¬ê¹€í”„ - ì§„ì…ê¹€í”„) â‰¥ 0.48%                    â”‚
â”‚             ì¡°ê±´ 2: í˜„ì¬ê¹€í”„ > BB_Upper(20, 2.0)                     â”‚
â”‚             í–‰ë™: ì „ëŸ‰ ì²­ì‚°                                          â”‚
â”‚             ê¸°ë¡: exit_reason = 'Breakout'                          â”‚
â”‚                                                                       â”‚
â”‚   â€» Track Aê°€ ë¨¼ì € ì²´í¬ë˜ë©°, A ì¡°ê±´ ì¶©ì¡± ì‹œ BëŠ” ì²´í¬í•˜ì§€ ì•ŠìŒ        â”‚
â”‚                                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 ì²­ì‚° ëª¨ë‹ˆí„° ì½”ë“œ

```python
from dataclasses import dataclass
from enum import Enum
from typing import Optional
import asyncio

class ExitReason(Enum):
    TARGET = "Target"      # Track A: ì •ìƒ ìµì ˆ
    BREAKOUT = "Breakout"  # Track B: BB ëŒíŒŒ íƒˆì¶œ

@dataclass
class ExitSignal:
    reason: ExitReason
    current_kimp: float
    entry_kimp: float
    profit_pct: float
    bb_upper: Optional[float]

@dataclass
class ExitResult:
    success: bool
    exit_reason: ExitReason
    realized_pnl: float
    realized_pnl_pct: float
    error: Optional[str]

class ExitMonitor:
    """ì²­ì‚° ëª¨ë‹ˆí„° (Ver 3.0 Dual Track)"""
    
    # ì²­ì‚° íŒŒë¼ë¯¸í„°
    TARGET_PROFIT_PCT = 0.70     # Track A: 0.7%
    BREAKOUT_MIN_PCT = 0.48      # Track B: ìµœì†Œ 0.48%
    BB_PERIOD = 20
    BB_STD_MULT = 2.0
    
    def __init__(self, data_feed, executor):
        self.data_feed = data_feed
        self.executor = executor
        self.monitoring = False
    
    async def start_monitoring(self, position):
        """ì²­ì‚° ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        self.monitoring = True
        
        while self.monitoring:
            # 1ì´ˆë§ˆë‹¤ ì²´í¬
            exit_signal = await self._check_exit_conditions(position)
            
            if exit_signal:
                result = await self.executor.execute_exit(position, exit_signal)
                self.monitoring = False
                return result
            
            await asyncio.sleep(1)
    
    async def _check_exit_conditions(self, position) -> Optional[ExitSignal]:
        """ì²­ì‚° ì¡°ê±´ ì²´í¬ (Dual Track)"""
        
        current_kimp = await self.data_feed.get_current_kimp()
        entry_kimp = position.entry_kimp
        profit_pct = current_kimp - entry_kimp
        
        # Track A: ì •ìƒ ìµì ˆ (ìš°ì„  ì²´í¬)
        if profit_pct >= self.TARGET_PROFIT_PCT:
            return ExitSignal(
                reason=ExitReason.TARGET,
                current_kimp=current_kimp,
                entry_kimp=entry_kimp,
                profit_pct=profit_pct,
                bb_upper=None
            )
        
        # Track B: Breakout íƒˆì¶œ
        if profit_pct >= self.BREAKOUT_MIN_PCT:
            bb_upper = await self._get_bb_upper()
            
            if current_kimp > bb_upper:
                return ExitSignal(
                    reason=ExitReason.BREAKOUT,
                    current_kimp=current_kimp,
                    entry_kimp=entry_kimp,
                    profit_pct=profit_pct,
                    bb_upper=bb_upper
                )
        
        return None
    
    async def _get_bb_upper(self) -> float:
        """ë³¼ë¦°ì € ë°´ë“œ ìƒë‹¨ ê³„ì‚°"""
        kimp_series = await self.data_feed.get_kimp_series(self.BB_PERIOD)
        
        mean = sum(kimp_series) / len(kimp_series)
        variance = sum((x - mean) ** 2 for x in kimp_series) / len(kimp_series)
        std = variance ** 0.5
        
        return mean + self.BB_STD_MULT * std
```

### 3.3 ì²­ì‚° ì‹¤í–‰ ì½”ë“œ

```python
class ExitExecutor:
    """ì²­ì‚° ì‹¤í–‰ê¸°"""
    
    def __init__(self, upbit_client, binance_client, db):
        self.upbit = upbit_client
        self.binance = binance_client
        self.db = db
    
    async def execute_exit(self, position, signal: ExitSignal) -> ExitResult:
        """ì²­ì‚° ì‹¤í–‰"""
        
        try:
            # ë™ì‹œ ì²­ì‚° ì‹¤í–‰
            upbit_result, binance_result = await asyncio.gather(
                self._close_upbit_position(position),
                self._close_binance_position(position),
                return_exceptions=True
            )
            
            if isinstance(upbit_result, Exception) or isinstance(binance_result, Exception):
                # ë¶€ë¶„ ì‹¤íŒ¨ ì²˜ë¦¬
                await self._handle_partial_failure(position, upbit_result, binance_result)
                return ExitResult(
                    success=False,
                    exit_reason=signal.reason,
                    realized_pnl=0,
                    realized_pnl_pct=0,
                    error=f"Partial failure: {upbit_result}, {binance_result}"
                )
            
            # ì†ìµ ê³„ì‚°
            realized_pnl = self._calculate_pnl(position, upbit_result, binance_result)
            realized_pnl_pct = (realized_pnl / position.total_invested) * 100
            
            # DB ì—…ë°ì´íŠ¸
            await self._update_position_closed(
                position=position,
                exit_reason=signal.reason.value,  # 'Target' or 'Breakout'
                exit_kimp=signal.current_kimp,
                exit_bb_upper=signal.bb_upper,
                realized_pnl=realized_pnl,
                realized_pnl_pct=realized_pnl_pct
            )
            
            return ExitResult(
                success=True,
                exit_reason=signal.reason,
                realized_pnl=realized_pnl,
                realized_pnl_pct=realized_pnl_pct,
                error=None
            )
            
        except Exception as e:
            return ExitResult(
                success=False,
                exit_reason=signal.reason,
                realized_pnl=0,
                realized_pnl_pct=0,
                error=str(e)
            )
    
    async def _close_upbit_position(self, position):
        """ì—…ë¹„íŠ¸ í˜„ë¬¼ ë§¤ë„"""
        return await self.upbit.create_market_sell_order(
            symbol='BTC/KRW',
            amount=position.upbit_amount
        )
    
    async def _close_binance_position(self, position):
        """ë°”ì´ë‚¸ìŠ¤ ì„ ë¬¼ ìˆ ì²­ì‚°"""
        return await self.binance.create_market_buy_order(
            symbol='BTC/USDT:USDT',
            amount=position.binance_amount,
            params={'reduceOnly': True}
        )
    
    async def _update_position_closed(
        self, 
        position, 
        exit_reason: str,
        exit_kimp: float,
        exit_bb_upper: Optional[float],
        realized_pnl: float,
        realized_pnl_pct: float
    ):
        """í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ DB ì—…ë°ì´íŠ¸"""
        await self.db.execute("""
            UPDATE positions SET
                status = 'closed',
                exit_timestamp = NOW(),
                exit_kimp = $1,
                exit_reason = $2,
                exit_bb_upper = $3,
                realized_pnl = $4,
                realized_pnl_pct = $5,
                updated_at = NOW()
            WHERE id = $6
        """, exit_kimp, exit_reason, exit_bb_upper, 
            realized_pnl, realized_pnl_pct, position.id)
```

---

## 4. í†µí•© ì‹¤í–‰ ë£¨í”„

### 4.1 ë©”ì¸ íŠ¸ë ˆì´ë”© ë£¨í”„

```python
class TradingBot:
    """ê¹€í”„ íŠ¸ë ˆì´ë”© ë´‡ (Ver 3.0)"""
    
    def __init__(self, config):
        self.config = config
        self.entry_executor = EntryExecutor(...)
        self.exit_monitor = ExitMonitor(...)
        self.signal_detector = SignalDetector(...)
        self.fx_filter = FXFilter(...)
        
        self.current_position = None
        self.running = False
    
    async def run(self):
        """ë©”ì¸ ë£¨í”„"""
        self.running = True
        
        while self.running:
            try:
                if self.current_position is None:
                    # ì§„ì… ì‹ í˜¸ íƒì§€
                    await self._check_entry()
                else:
                    # ì²­ì‚° ì‹ í˜¸ íƒì§€ (1ì´ˆë§ˆë‹¤)
                    await self._check_exit()
                
                await asyncio.sleep(1)
                
            except Exception as e:
                await self._handle_error(e)
    
    async def _check_entry(self):
        """ì§„ì… ì²´í¬"""
        signal = await self.signal_detector.detect()
        
        if signal:
            # í™˜ìœ¨ í•„í„° ìƒíƒœ ë¡œê¹…
            fx_status = self.fx_filter.check(
                signal.fx_rate, 
                signal.fx_ma_12h
            )
            
            if fx_status.is_blocked:
                print(f"â›” Entry blocked by FX filter: +{fx_status.surge_pct:.2f}%")
                return
            
            # ì§„ì… ì‹¤í–‰
            result = await self.entry_executor.execute_entry(signal)
            
            if result.success:
                self.current_position = await self._load_position(result.position_id)
                print(f"âœ… Entry: {signal.level.value} | Z: {signal.zscore:.2f}")
    
    async def _check_exit(self):
        """ì²­ì‚° ì²´í¬"""
        exit_signal = await self.exit_monitor._check_exit_conditions(
            self.current_position
        )
        
        if exit_signal:
            result = await self.exit_monitor.executor.execute_exit(
                self.current_position, 
                exit_signal
            )
            
            if result.success:
                reason_emoji = "ğŸ¯" if result.exit_reason == ExitReason.TARGET else "ğŸš€"
                print(f"{reason_emoji} Exit ({result.exit_reason.value}): {result.realized_pnl_pct:.2f}%")
                self.current_position = None
```

---

## 5. ì—ëŸ¬ ì²˜ë¦¬

### 5.1 ì£¼ë¬¸ ì‹¤íŒ¨ ì‹œë‚˜ë¦¬ì˜¤

| ì‹œë‚˜ë¦¬ì˜¤ | ì²˜ë¦¬ ë°©ë²• |
|:---|:---|
| Upbitë§Œ ì²´ê²° | Upbit ì¦‰ì‹œ ë°˜ëŒ€ë§¤ë§¤ (ì†ì‹¤ ìµœì†Œí™”) |
| Binanceë§Œ ì²´ê²° | Binance í¬ì§€ì…˜ ì²­ì‚° |
| ì–‘ìª½ ëª¨ë‘ ì‹¤íŒ¨ | ì¬ì‹œë„ (ìµœëŒ€ 3íšŒ) |
| ë¶€ë¶„ ì²´ê²° | ì²´ê²°ëœ ë¶€ë¶„ë§Œ ë¡¤ë°± |

### 5.2 ë„¤íŠ¸ì›Œí¬ ì¥ì•  ëŒ€ì‘

```python
class RetryHandler:
    """ì¬ì‹œë„ í•¸ë“¤ëŸ¬"""
    
    MAX_RETRIES = 3
    RETRY_DELAY = 1.0
    
    async def execute_with_retry(self, func, *args, **kwargs):
        last_error = None
        
        for attempt in range(self.MAX_RETRIES):
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                last_error = e
                print(f"Attempt {attempt + 1} failed: {e}")
                
                if attempt < self.MAX_RETRIES - 1:
                    await asyncio.sleep(self.RETRY_DELAY * (attempt + 1))
        
        raise last_error
```

---

## 6. ë¡œê¹… ë° ì•Œë¦¼

### 6.1 ê±°ë˜ ë¡œê·¸

```python
import logging

# ê±°ë˜ ë¡œê±° ì„¤ì •
trade_logger = logging.getLogger('trade')
trade_logger.setLevel(logging.INFO)

# ê±°ë˜ ê¸°ë¡ í¬ë§·
def log_entry(signal, result):
    trade_logger.info(
        f"ENTRY | Level: {signal.level.value} | "
        f"Z-Score: {signal.zscore:.2f} | "
        f"Kimp: {signal.kimp:.2f}% | "
        f"FX: {signal.fx_rate:.2f} | "
        f"Success: {result.success}"
    )

def log_exit(signal, result):
    trade_logger.info(
        f"EXIT | Reason: {result.exit_reason.value} | "
        f"PnL: {result.realized_pnl:,.0f}ì› ({result.realized_pnl_pct:.2f}%) | "
        f"Kimp: {signal.current_kimp:.2f}% â†’ {signal.entry_kimp:.2f}%"
    )
```

### 6.2 Telegram ì•Œë¦¼

```python
async def send_telegram_alert(bot, chat_id, message_type, data):
    """Telegram ì•Œë¦¼ ì „ì†¡"""
    
    if message_type == 'entry':
        text = (
            f"ğŸ“ˆ *ì§„ì… ì™„ë£Œ*\n"
            f"Level: {data['level']}\n"
            f"Z-Score: {data['zscore']:.2f}\n"
            f"ê¹€í”„: {data['kimp']:.2f}%\n"
            f"í™˜ìœ¨: {data['fx_rate']:.2f}"
        )
    
    elif message_type == 'exit':
        emoji = "ğŸ¯" if data['reason'] == 'Target' else "ğŸš€"
        text = (
            f"{emoji} *ì²­ì‚° ì™„ë£Œ* ({data['reason']})\n"
            f"ìˆ˜ìµ: {data['pnl']:,.0f}ì› ({data['pnl_pct']:.2f}%)\n"
            f"ê¹€í”„: {data['entry_kimp']:.2f}% â†’ {data['exit_kimp']:.2f}%"
        )
    
    elif message_type == 'fx_blocked':
        text = (
            f"â›” *ì§„ì… ì°¨ë‹¨ (í™˜ìœ¨ ê¸‰ë“±)*\n"
            f"í˜„ì¬ í™˜ìœ¨: {data['rate']:.2f}\n"
            f"ì„ê³„ê°’: {data['threshold']:.2f}\n"
            f"ê¸‰ë“±ë¥ : +{data['surge_pct']:.2f}%"
        )
    
    await bot.send_message(chat_id, text, parse_mode='Markdown')
```

---

## 7. ì„¤ì •

```yaml
# config/order_config.yaml
execution:
  # ì§„ì…
  entry:
    fx_surge_threshold: 1.001  # +0.1%
    order_type: "market"
    max_retries: 3
    retry_delay: 1.0
  
  # ì²­ì‚° - Dual Track
  exit:
    track_a:
      target_profit_pct: 0.70
    track_b:
      breakout_min_pct: 0.48
      bb_period: 20
      bb_std_mult: 2.0
    
    check_interval: 1  # ì´ˆ
    order_type: "market"
  
  # ë¡¤ë°±
  rollback:
    enabled: true
    max_retries: 3
```

---

**ë²„ì „**: 3.0  
**ì‘ì„±ì¼**: 2025-12-14  
**ë ˆí¬**: trading-platform-order
